---
title: 你不知道的JS（上卷）this和对象原型
date: 2020-06-01 15:27:26
permalink: /pages/dd8488/
categories: 
  - 读书笔记
  - 你不知道的JS
tags: 
  - 
---
# 上卷一 this 和对象原型

### 前言

在经历上一轮面试之后，得到朋友的推荐，看了红宝书，突然感觉很多问题明了很多！作为 JS 方面的两大神书，怎么能落下《你不知道的 JS》呢！从今天开始，基于自己的情况，准备暂时先过一下本书的上卷和中卷。冲哇~~~

> 本系列内容摘抄或总结自《你不知道的 JavaScript》（上卷）

---

## 一、关于 this

### 1、为什么要用 this

this 提供了一种更优雅的方式来**隐式**“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用。

### 2、误解

- **函数内部的 this 并不是指向函数本身的**
- 如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。

```js
function foo() {
	foo.count = 4; // foo 指向它自身
}
```

- 匿名函数没有名称标识符，无法从内部引用自身。
- **this 在任何情况下都不指向函数的词法作用域**
- 不能使用 this 来引用一 个词法作用域内部的东西。

### 3、this 到底是什么

之前我们说过 this 是在**运行时进行绑定**的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。**this 的绑定和函数声明的位置没有任何关系**，只取决于函数的调用方式。

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被**调用（调用栈）、函数的调用方法、传入的参数**等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。

### 4、小结

- this 既不指向**函数自身也不指向函数的词法作用域**，你也许被这样的解释误导过，但其实它们都是错误的。
- this 实际上是在函数被**调用时**发生的绑定，它指向什么完全取决于函数在哪里被调用。

## 二、this 全面解析

### 1、调用位置

- **调用位置**就是函数在代码中被调用的位置（而不是声明的位置）。

调用栈和调用位置之间的关系：

```js
function baz() {
	// 当前调用栈是：baz
	// 因此，当前调用位置是全局作用域
	console.log('baz');
	bar(); // <-- bar的调用位置
}
function bar() {
	// 当前调用栈是 baz -> bar
	// 因此，当前调用位置在 baz 中
	console.log('bar');
	foo(); // <-- foo 的调用位置
}
function foo() {
	// 当前调用栈是 baz -> bar -> foo
	// 因此，当前调用位置在 bar 中
	console.log('foo');
}
baz(); // <-- baz 的调用位置
```

### 2、绑定规则

找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。

#### 2.1 默认绑定

- 首先要介绍的是最常用的函数调用类型：**独立函数调用**。可以把这条规则看作是无法应用其他规则时的默认规则。

- 在代码中，函数是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。

- 如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined：

#### 2.2 隐式绑定

- 另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个**对象**拥有或者包含，不过这种说法可能会造成一些误导。

#### 2.3 显式绑定

**call(..) apply(..)**

它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。

#### 2.4 new 绑定

- 在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。

### 3、优先级

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。
   `var bar = new foo()`
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。`var bar = foo.call(obj2)`
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 `var bar = obj1.foo()`
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。`var bar = foo()`

### 4、绑定例外

**被忽略的 this**

- 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则。
- Object.create(null) 和 {} 很像，但是并不会创建 Object. prototype 这个委托，所以它比 {}“更空”。

**间接引用**

间接引用情况下，调用这个函数会应用默认绑定规则。
对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。

**软绑定**

如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。

### 5、this 词法

箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 => 定 义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。

### 6、小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。

1. 由 new 调用？绑定到新创建的对象。
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø =Object.create(null)，以保护全局对象。

ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。

## 三、对象

### 1、语法

对象可以通过两种形式定义：声明（文字）形式和构造形式。

```js
// 对象的文字语法大概是这样：
var myObj = {
	key: value,
};
// 构造形式大概是这样：
var myObj = new Object();
myObj.key = value;
```

### 2、类型

有六种主要类型（术语是“语言类型”）：
`string`、`number`、`boolean`、`null`、 `undefined`、 `object`

> 简单基本类型（string、boolean、number、null 和 undefined）本身并不是对象。
> null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 "object"。实际上，null 本身是基本类型。

**内置对象**

JavaScript 中还有一些对象子类型，通常被称为**内置对象**。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂`String`、`Number`、 `Boolean`、 `Object`、`Function`、 `Array`、`Date`、`RegExp`、`Error`

对于 `Object`、`Array`、`Function` 和 `RegExp`（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。

`Error` 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。

也可以使用 `new Error(..)`这种构造形式来创建，不过一般来说用不着。

### 3、内容

对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的， 我们称之为属性。

在引擎内部，这些值的存储方式是多种多样的，一般并不会存 在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针(从技术角度 来说就是引用)一样，指向这些值真正的存储位置。

**在对象中，属性名永远都是字符串**。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串。

### 3.1 　可计算属性名

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:

```js
var prefix = 'foo';
var myObject = {
	[prefix + 'bar']: 'hello',
	[prefix + 'baz']: 'world',
};
myObject['foobar']; // hello
myObject['foobaz']; // world
```

### 3.2 　属性与方法

函数不可能属于某个对象，对象内部的函数只是一个引用。

### 3.3 　数组

### 3.4 　复制对象

### 3.5 　属性描述符

### 3.6 　不变性

### 3.7 　[[Get]]

### 3.8 　[[Put]]

### 3.9 　 Getter 和 Setter

### 3.10 　存在性

### 4、遍历

### 5、小结

## 四、混合对象“类”

### 1、类理论 4.1.1 　 “类”设计模式

### 1.2 　 JavaScript 中的“类”

### 2、类的机制

### 2.1 　建造

### 2.2 　构造函数

### 3、类的继承

### 3.1 　多态

### 3.2 　多重继承

### 4、混入

### 4.1 　显式混入

### 4.2 　隐式混入

### 5、小结

## 五、原型

### 1、[[Prototype]]

### 1.1 　 Object.prototype

### 1.2 　属性设置和屏蔽

### 2、“类”

### 2.1 　“类”函数

### 2.2 　“构造函数”

### 2.3 　技术

### 3、（原型）继承

### 4、对象关联

### 4.1 　创建关联

### 4.2 　关联关系是备用

### 5、小结

## 六、行为委托

### 1、面向委托的设计

### 1、1 　类理论

### 1、2 　委托理论

### 1、3 　比较思维模型

### 2、类与对象

### 2、1 　控件“类”

### 2、2 　委托控件对象

### 3、更简洁的设计

### 4、更好的语法

### 5、内省

### 6、小结
